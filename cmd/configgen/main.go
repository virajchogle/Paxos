// cmd/configgen/main.go
// Configuration Generator for Configurable Clusters
// This tool generates nodes.yaml configuration files with customizable cluster layouts

package main

import (
	"flag"
	"fmt"
	"os"

	"gopkg.in/yaml.v3"
)

// ClusterConfig represents a single cluster's configuration
type ClusterConfig struct {
	ID         int   `yaml:"id"`
	ShardStart int32 `yaml:"shard_start"`
	ShardEnd   int32 `yaml:"shard_end"`
	Nodes      []int `yaml:"nodes"`
}

// NodeConfig represents a single node's configuration
type NodeConfig struct {
	ID      int    `yaml:"id"`
	Cluster int    `yaml:"cluster"`
	Address string `yaml:"address"`
	Port    int    `yaml:"port"`
}

// DataConfig represents data configuration
type DataConfig struct {
	TotalItems         int   `yaml:"total_items"`
	InitialBalance     int32 `yaml:"initial_balance"`
	CheckpointInterval int32 `yaml:"checkpoint_interval"`
}

// Config represents the full configuration
type Config struct {
	Clusters map[int]ClusterConfig `yaml:"clusters"`
	Nodes    map[int]NodeConfig    `yaml:"nodes"`
	Data     DataConfig            `yaml:"data"`
}

func main() {
	numClusters := flag.Int("clusters", 3, "Number of clusters")
	nodesPerCluster := flag.Int("nodes-per-cluster", 3, "Number of nodes per cluster")
	totalItems := flag.Int("items", 9000, "Total number of data items")
	basePort := flag.Int("base-port", 50051, "Base port number for nodes")
	initialBalance := flag.Int("initial-balance", 10, "Initial balance for each data item")
	checkpointInterval := flag.Int("checkpoint-interval", 100, "Checkpoint interval")
	outputFile := flag.String("output", "config/nodes.yaml", "Output file path")
	address := flag.String("address", "localhost", "Address for all nodes")
	flag.Parse()

	if *numClusters < 1 {
		fmt.Println("Error: Number of clusters must be at least 1")
		os.Exit(1)
	}
	if *nodesPerCluster < 1 {
		fmt.Println("Error: Nodes per cluster must be at least 1")
		os.Exit(1)
	}
	if *totalItems < *numClusters {
		fmt.Printf("Error: Total items (%d) must be at least equal to number of clusters (%d)\n", *totalItems, *numClusters)
		os.Exit(1)
	}

	config := generateConfig(*numClusters, *nodesPerCluster, *totalItems, *basePort, *initialBalance, *checkpointInterval, *address)

	// Generate YAML with header comment
	itemsPerCluster := *totalItems / *numClusters
	header := fmt.Sprintf(`# Multi-cluster configuration: %d nodes organized into %d clusters
# Generated by configgen tool
# Each cluster has %d nodes
# Total data items: %d (%d items per cluster)
#
# Usage:
#   ./bin/configgen -clusters=4 -nodes-per-cluster=5  # 4 clusters, 2250 items each
#   ./bin/configgen -clusters=3 -nodes-per-cluster=3  # default (9000 items / 3 = 3000 each)
#
`, *numClusters**nodesPerCluster, *numClusters, *nodesPerCluster, *totalItems, itemsPerCluster)

	data, err := yaml.Marshal(&config)
	if err != nil {
		fmt.Printf("Error marshaling config: %v\n", err)
		os.Exit(1)
	}

	output := header + string(data)

	err = os.WriteFile(*outputFile, []byte(output), 0644)
	if err != nil {
		fmt.Printf("Error writing config file: %v\n", err)
		os.Exit(1)
	}

	fmt.Printf("âœ… Generated configuration:\n")
	fmt.Printf("   Clusters: %d\n", *numClusters)
	fmt.Printf("   Nodes per cluster: %d\n", *nodesPerCluster)
	fmt.Printf("   Total nodes: %d\n", *numClusters**nodesPerCluster)
	fmt.Printf("   Data items: %d\n", *totalItems)
	fmt.Printf("   Items per cluster: %d\n", *totalItems / *numClusters)
	fmt.Printf("   Output: %s\n", *outputFile)
}

func generateConfig(numClusters, nodesPerCluster, totalItems, basePort, initialBalance, checkpointInterval int, address string) Config {
	config := Config{
		Clusters: make(map[int]ClusterConfig),
		Nodes:    make(map[int]NodeConfig),
		Data: DataConfig{
			TotalItems:         totalItems,
			InitialBalance:     int32(initialBalance),
			CheckpointInterval: int32(checkpointInterval),
		},
	}

	// Calculate items per cluster (evenly distributed)
	itemsPerCluster := totalItems / numClusters
	remainderItems := totalItems % numClusters

	nodeID := 1
	shardStart := int32(1)

	for clusterID := 1; clusterID <= numClusters; clusterID++ {
		// Calculate shard range for this cluster
		// Distribute remainder items to first clusters
		clusterItems := itemsPerCluster
		if clusterID <= remainderItems {
			clusterItems++
		}

		shardEnd := shardStart + int32(clusterItems) - 1

		// Create node list for this cluster
		clusterNodes := make([]int, nodesPerCluster)
		for i := 0; i < nodesPerCluster; i++ {
			clusterNodes[i] = nodeID

			// Add node config
			config.Nodes[nodeID] = NodeConfig{
				ID:      nodeID,
				Cluster: clusterID,
				Address: address,
				Port:    basePort + nodeID - 1,
			}

			nodeID++
		}

		// Add cluster config
		config.Clusters[clusterID] = ClusterConfig{
			ID:         clusterID,
			ShardStart: shardStart,
			ShardEnd:   shardEnd,
			Nodes:      clusterNodes,
		}

		shardStart = shardEnd + 1
	}

	return config
}
